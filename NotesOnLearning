Cpp important points come across in learning
=============================================
C++completeReference
=====================


Friend Function
==============
1. First,friends can be useful when you are overloading certain types of operators (seeChapter14).
Second,friendfunctionsmakethecreationofsometypesofI/O functionseasier(seeChapter18).Thethirdreasonthatfriendfunctionsmaybedesirable 
isthatinsomecases,twoormoreclassesmaycontainmembersthatareinterrelated relativetootherpartsofyourprogram


static data member
===================

One use of a static member variable is to provide access control to some shared resource used by all objects of a class. 
For example, you might create several objects, each of which needs to write to a specific disk file. Clearly, 
however, only one object can be allowed to write to the file at a time. In this case, you will want to declare a static 
variable that indicates when the file is in use and when it is free. Each object then interrogates this variable before 
writing to the file. The following program shows how you might use a static variable of this type to control access to a 
scarce resource:

As you can see, the static member variable count is incremented whenever an object is created and decremented when an 
object is destroyed. This way, it keeps track of how many objects of type Counter are currently in existence. 

By using static member variables, you should be able to virtually eliminate any need for global variables. 

The trouble with global variables relative to OOP is that they almost always violate the principle of encapsulation. 

static member functions
=======================
They may only directly refer to other static members of the class. (Of course, global functions and data may be accessed by
static member functions.) A static member function does not have a this pointer. (See Chapter 13 for information on this.) 
There cannot be a static and a non-static version of the same function. 
A static member function may not be virtual. Finally, they cannot be declared as const or volatile. 


constructors
There are some restrictions that apply to friend operator functions. First, you may not overload the =, ( ), [ ],or –> operators by using a friend function. Second, as explained in the next section, when overloading the increment or decrement operators, you will need to use a reference parameter when using a friend function. =============
Global objects have their constructor functions execute before main() begins execution. Global constructors 
are executed in order of their declaration, within the same file. You cannot know the order of execution of global 
constructors spread among several files. 
Global destructors execute in reverse order after main() has terminated


 When you pass an object to a function, you want the current state of that object. If the constructor is  called when the copy is created, initialization will occur, possibly changing the object. Thus, the constructor function 
 cannot be executed when the copy of an object is generated in a function call. Although the constructor function is 
 not called when an object is passed to a function, it is necessary to call the destructor when the copy is destroyed. 
 (The copy is destroyed like any other local variable, when the function terminates.) 
 Remember, a new copy of the object has been created when the copy is made.

reference
=========
C++ contains a feature that is related to the pointer called a reference. A reference is
essentially an implicit pointer. There are three ways that a reference can be used: as a
function parameter, as a function return value, or as a stand-alone reference. Each is
examined here

Restrictions to References
There are a number of restrictions that apply to references. You cannot reference
another reference. Put differently, you cannot obtain the address of a reference. You
cannot create arrays of references. You cannot create a pointer to a reference. You
cannot reference a bit-field.
A reference variable must be initialized when it is declared unless it is a member of
a class, a function parameter, or a return value. Null references are prohibited


Although new and delete perform functions similar to malloc() and free(), they
have several advantages. First, new automatically allocates enough memory to hold an
object of the specified type. You do not need to use the sizeof operator. Because the size
is computed automatically, it eliminates any possibility for error in this regard. Second,
new automatically returns a pointer of the specified type. You don't need to use an
explicit type cast as you do when allocating memory by using malloc(). Finally, both
new and delete can be overloaded, allowing you to create customized allocation systems.
Although there is no formal rule that states this, it is best not to mix new and delete
with malloc() and free() in the same program. There is no guarantee that they are
mutually compatible.

function overloading
=====================
Function overloading is one of the defining aspects of the C++ programming language. Not only does it provide support for 
compile-time polymorphism, it also adds flexibility and convenience. Some of the most commonly overloaded functions are constructors.
Perhaps the most important form of an overloaded constructor is the copy constructor. Closely related to function overloading are 
default arguments. Default arguments can sometimes provide an alternative to function overloading.

There are some restrictions that apply to friend operator functions. First, you may not overload the =, ( ), [ ],or –> operators by using a friend function. 
Second, as explained in the next section, when overloading the increment or decrement operators, you will need to use a reference parameter when using a friend function.


1. Alaways use assert to check index passed as a parameter to function of an array before using the array
2. Subscript operator should return & reference to the value of an array why because the assignemnt operator requires
  an l value that means a memory to assign the the value. for example int arr[2]=5; writing into an array at index 2 so we
  need the address. It won't work if it is like this, if subscript operator returns value  for example arr[2]'s value is 3
  the assignment would be like this arr[2]=5; //2=5 error l value required by compiler
3.Rule: Make sure you’re not trying to call an overloaded operator[] on a pointer to an object.
4.Don’t set pointers to your objects if you don’t have to. IntList *list = new IntList;
    (*list)[2] = 3; // get our IntList object, then call overloaded operator[]
    delete list;
    
 5.Overloading operator[] to take a std::string parameter can be useful when writing certain kinds of classes, such as those that use words as indices.
Conclusion
The subscript operator is typically overloaded to provide direct access to individual elements from an array (or other similar structure) contained within a class. Because strings are often implemented as arrays of characters, operator[] is often implemented in string classes to allow the user to access a single character of the string.


