Exceptions
==========
Exceptions provide a way to react to exceptional circumstances (like runtime errors) in programs by transferring control to special functions called handlers.

To catch exceptions, a portion of code is placed under exception inspection. This is done by enclosing that portion of code in a try-block. When an exceptional circumstance arises within that block, an exception is thrown that transfers the control to the exception handler. If no exception is thrown, the code continues normally and all handlers are ignored.

An exception is thrown by using the throw keyword from inside the try block. Exception handlers are declared with the keyword catch, which must be placed immediately after the try block:
std::exception
  C++  Utilities library  Error handling std::exception 
Defined in header <exception>
class exception;
Provides consistent interface to handle errors through the throw expression.

All exceptions generated by the standard library inherit from std::exception

logic_error
invalid_argument
domain_error
length_error
out_of_range
future_error(C++11)
bad_optional_access(C++17)
runtime_error
range_error
overflow_error
underflow_error
regex_error(C++11)
nonexistent_local_time(C++20)
ambiguous_local_time(C++20)
tx_exception(TM TS)
system_error(C++11)
ios_base::failure(C++11)
filesystem::filesystem_error(C++17)
bad_typeid
bad_cast
bad_any_cast(C++17)
bad_weak_ptr(C++11)
bad_function_call(C++11)
bad_alloc
bad_array_new_length(C++11)
bad_exception
ios_base::failure(until C++11)
bad_variant_access(C++17)
Member functions
(constructor)
 
constructs the exception object 
(public member function)
(destructor)
  
[virtual]
 
destroys the exception object 
(virtual public member function)
operator=
 
copies exception object 
(public member function)
what
  
[virtual]
 
returns an explanatory string 
(virtual public member function)
